Reflection on My C++ Test Experience

As I continue to develop my skills in C++, I approached the recent coding test as an valuable learning 
opportunity. Although I am not an expert, I made a deliberate effort to identify and understand key 
concepts throughout the exercise. Below is a summary of the lessons I gained, particularly in areas such
as memory management, constructors, and safe coding practices. While my current proficiency may not fully 
meet your expectations, I hope this demonstrates my commitment to learning and growth. With the right 
guidance, I am confident I can strengthen my skills and contribute by writing more robust and efficient 
C++ code in the future :)


Garbage Collection:
- Unlike other languages, C++ does not use garbage collection and so we must manage deleted objects manually.


Constructors
- A default constructor takes no arguments and initializes an object with default values, while a parameterized constructor accepts arguments to initialize an object with specific, user-defined values.
- A class can have many parameterized constructors for different outcomes.


Memory allocation
- Member variables must be initialized to prevent undefined behavior.
-  the 'new' operator allocates memory on the heap.
- Every 'new' should have a corresponding 'delete' to prevent memory leaks.
- Arrays allocated with new[] must be freed with delete[]; otherwise, undefined behavior occurs.
- Buffer overflow happens when data exceeds the allocated memory space, leading to potential crashes or security vulnerabilities.
- Smart pointers


Smart Pointers:
- I learned about smart pointers and their role in automatic memory management, though I did not use them in this test. I understand they help prevent memory leaks by managing object lifetimes more safely than raw pointers.
- I chose to stick with manually managing and deleting raw pointers because I wasn’t sure of the expectations for the test and I’m still getting accustomed to using smart pointers in practice.


Stings and Char
- Strings in C++ are arrays of char plus a null terminator ('\0').
- Each char occupies 1 byte.
- When allocating memory for strings, always allocate space for the null terminator as well.

Pathfinding Algorithms:
- BFS (Breadth-First Search): explores nodes level by level, finds shortest path in terms of edges on unweighted graphs. Useful for board games or games like pacman where all edges are the same length
- Dijkstra’s algorithm: finds the shortest path in weighted graphs by accounting for edge costs, guaranteeing minimal total distance. Useful for game where edges have different weights (like distance). 

If you want, I can also help you **add one short, personal “lesson learned” line** to make it clear you successfully applied these in your project. Do you want me to do that?


Null pointers
- Use nullptr instead of NULL for type safety.
- Never call strcpy (or similar functions) on a null pointer to avoid undefined behavior.


Vector Library
- In C++, a vector is a container that holds a sequence of elements.
- You create a vector using std::vector<Type>, e.g., std::vector<int> numbers;.
- To iterate over elements safely and efficiently, you use an iterator, which acts like a pointer to elements in the vector.
- myVector.begin() returns an iterator to the first element of the vector.
- myVector.end() returns an iterator to one past the last element.
- myVector.erase() remove an entry from the container and resizes it, moving all the other elements.
- calling myVector.erase() on an iterator equal to end() can result in undefined behavior

Unordered Maps
- we use unordered_maps when we need a fast, flexible way to associate one piece of data (value) with another (key).
- std::unordered_map<KeyType, ValueType> stores key-value pairs in a hash table.
        - Key: input type (e.g., PathNode*)
        - Value: output type (e.g., float)
        - Accessing or assigning works like a function: mapName[key] = value;
- In Dijkstra’s Algorithm:
        - shortestDistance stores the shortest distance to each node from the start.
        - previousNode: stores the previous node on the shortest path for reconstruction.
        - Together, they track the algorithm’s progress and allow path reconstruction.


Type Alias
- Use typedef or using to create aliases for complex types to simplify code readability.
        Example: typedef std::vector<PathNode*> PathNodes; so you can just write PathNodes instead of std::vector<PathNode*>.
- 'using' is another way to declare a type alias.

Lambda Functions:
- Lambda expressions let you define small, inline functions directly where you need them, as opposed to defining them elsewhere in our code.
- decltype() is required when a lambda's type is used as a class template parameter.

SORT:
#include <queue>
#include <limits>